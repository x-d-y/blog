---
title: innodb体系架构 --后台线程
date: 2019-08-31 14:59:57
tags: 数据库
---
&#160;&#160;&#160;&#160;&#160;&#160;作为mysql的默认数据库引擎，innodb一直是很多大公司后台免费数据库引擎的首选。innodb的强大之处得益于它的架构设计。本篇文章将介绍innodb引擎的的后台线程设计，在讲到后台线程设计之前，先来看看innodb的整体架构设计。innodb的架构分为两层，一层是后台的线程，可以认为它是数据库程序，数据处理都是这些线程在执行。innodb存储引擎内存中主要是以不同的数据结构存储相应的数据，数据来源是下面的磁盘文件。它的作用是在用户执行数据库操作时，保证磁盘文件内相应的数据在这部分内存中，从而加速数据操作。
<div align= center>
<img src="https://github.com/x-d-y/blog/blob/master/source/_posts/innodb%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B/innodb%E6%9E%B6%E6%9E%84.png?raw=true" width="300">
</div>
### 后台线程

#### 1.Master Thread
&#160;&#160;&#160;&#160;&#160;&#160;Master Thread是后台线程中最核心的部分，它的主要职责就是将内存中的数据按一定方存储到磁盘文件中，从而保证了内存数据和磁盘数据的一致性。包括的操作为数据脏页的刷新、合并插入缓冲、UNDO页的回收、日志文件的写入和切换到不同的循环模式中。Master Thread首先会在主循环(loop)中进行循环，主循环主要包括两个操作：1.一秒一次的执行，执行十次 2.十秒一次的执行。
###### 一秒一次的执行：
1) 将日志缓冲刷新到磁盘中(一定会做)
2) 合并插入缓冲(按条件执行：如果前一秒的IO次数小于5次，开始执行)
3) 最多刷新100个脏页到磁盘中(按条件执行：查看当前脏页比例，如果超过90%，开始执行)
4) 切换到后台循环中(按条件执行：如果用户没有任何活动，进入该模式)

当一秒一次的任务执行十次之后，开始执行十秒一次的任务。
###### 十秒一次的执行：
1) 刷新100个脏页到磁盘中(按条件执行：查看过去10秒的IO操作，如果小于200次，则执行)
2) 合并最多5个插入缓冲(一定会做)
3) 将日志缓冲写入到磁盘(一定会做)
4) 删除废弃的Undo页(一定会做)
5) 刷新100个或者10个脏页到磁盘(一定会做：如果脏页比例超过70%刷新100个脏页，否则刷新10个脏页)

从以上的步骤中，可以看出，一秒一次的操作大多数是在按照一定的条件开始执行，但十秒一次的执行大多是一定会做的。当用户没有在操作数据库的时候，可以认为此时的数据库处于空闲状态，主线程会立马切换到后台循环(backgroud loop)

###### background loop：
1) 删除无用的Undo页(一定会做)
2) 合并20个插入缓冲(一定会做)
3) 跳到主循环(一定会做)
4) 不断的刷新100个页直到符合条件(跳转到刷新循环(flush loop))
<!--more-->
如果最终flush loop中也没有任何事情可以做，就会直接跳转到暂停循环中将Master Thread 进行挂起，等待下一次的用户操作。整个过程的伪代码如下所示：

<div align= center>
<img src="https://github.com/x-d-y/blog/blob/master/source/_posts/innodb%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B/1.png?raw=true" width="600">
<div>
<div align= center>
<img src="https://github.com/x-d-y/blog/blob/master/source/_posts/innodb%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B/2.png?raw=true" width="600">
<div>

&#160;&#160;&#160;&#160;&#160;&#160;但是随着计算机硬件的增强，IO阻塞问题不在是限制数据库性能的最大瓶颈，反而是硬编码中每次按条件处理的页数量。即每次处理的最大数据量没有触碰到计算机硬件的最大极限。于是基于该问题，做了如下几个方面的调整：

1） 在合并缓冲的时候，如果上一秒的IO操作占到IO操作能力的5%以内，将合并5%的插入缓冲。
2） 当脏页的数目超过最大脏页设定值，将通过Redo log产生的速度来决定最终要刷新的脏页数目
3） 最后一个改变是回收Undo页的时候至少为20个

经过改进之后的伪代码为：

<div align= center>
<img src="https://github.com/x-d-y/blog/blob/master/source/_posts/innodb%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84-%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B/3.png?raw=true" width="600">
<div>

最后在InnoDB 1.2.x中进一步进行改进，对于新脏页的处理方式直接分配给 Page Cleaner Thread 来做，进一步利用了计算机硬件，加快了处理速度，并且降低了Master Thread的处理压力。

#### 2. IO Thread
&#160;&#160;&#160;&#160;&#160;&#160;IO Thread会借助AIO(Async IO，异步IO)技术负责IO请求的回调处理。目前的IO Thread 主要有4个读IO线程与4个写IO线程。并且读写IO线程可以通过设定改变他们的数量

#### 3.Purge Thread
&#160;&#160;&#160;&#160;&#160;&#160;当事务提交之后，Undo log在不需要保留的情况下，会通过Purge Thread进行处理，这样会留出相应的资源供其他请求使用。

#### 4.Page Cleaner Thread
&#160;&#160;&#160;&#160;&#160;&#160;在上文中提到的，为了减缓Master Thread的执行压力，所有的脏页刷新全部由该Page Cleaner Thread进行处理
