---
title: 进程、线程与协程
date: 2019-08-15 20:45:09
tags: 杂项
---
&#160;&#160;&#160;&#160;&#160;&#160;本篇文章将要讲解如下内容：

- 进程(Process)
- 线程(Thread)
- 协程(Coroutine)

### 进程

&#160;&#160;&#160;&#160;&#160;&#160;进程是操作系统进行调度的，是计算机资源分配的最小单位。当一个程序启动时，会开启进程，进程的数量多于或等于一个。以进程为单位，操作系统会分配系统资源，并且这些资源之间是相互隔离的。这些被相互隔离的资源通常被成为执行上下文COE(context of execution)。
<!-- more-->
&#160;&#160;&#160;&#160;&#160;&#160;COE包括以下四个内容：

1. CPU状态：CPU数据和指令
2. MMU状态：内存管理，虚拟内存
3. Permission状态：权限管理
4. Communication状态：通信管理

进程之间的COE是完全隔离的，对于编写程序时，需要明确的是在内存状态中，不同的进程会有不同的堆和栈。堆内的内容存放时顺序是从低内存地址递增往高内存地址存放，而栈内的内容是倒着存放。

### 进程的创建方式
&#160;&#160;&#160;&#160;&#160;&#160;进程都是以fork的方式开始创建，新fork出来的子进程在没有写入任何信息时与父进程共用同一块内存空间存放数据、打开文件、线程信息等等。这么做的目的是能够尽量占用少的资源快速创建新的进程，与父进程公用大量的资源。但新创建的进程在使用后(有写操作时)终究是要进行资源隔离的。系统会进行exec操作，加载相关需要的文件内容覆盖到子进程上，使子进程和父进程完全的隔离开。程序以不同的方式进行启动，其父进程不相同。如果是遂系统一起启动的进程，其父进程是init，如果是在shell中启动，其父进程是shell,如果是在图形界面启动其父进程为砖面管理器gnome或kde等。
<div align=center>
<img src= "https://github.com/x-d-y/blog/blob/master/source/_posts/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/process_fork_ecex.png?raw=true" width = 800>

</div>

### 进程的类型
#### 孤儿进程
&#160;&#160;&#160;&#160;&#160;&#160;系统会根据用户的需求不断的fork出新的进程，进程会产生父进程、子进程、孙子进程等等。如果父进程被销毁，如kill -9等。会导致子进程找不到父进程，形象的比喻为孤儿进程。这时就会有孤儿院专门进行收养，即系统最先创建的init进程。孤儿进程不会造成资源浪费。
#### 僵尸进程
&#160;&#160;&#160;&#160;&#160;&#160;僵尸进程，顾名思义就是已经死掉的进程，尸体还在，即子进程被杀死后，其父进程不知道该进程已经死亡。在创建该进程之前系统为该进程分配了很多的系统资源。但是系统不知道该进程已经死亡，也就无法回收该进程生前所占用的资源。解决僵尸进程的方法也很直接，直接杀死父进程，僵尸进程变成孤儿进程从而被init回收。
#### 守护进程
&#160;&#160;&#160;&#160;&#160;&#160;守护进程是一直运行在后台的进程，起守护作用。一般也可以作为避免僵尸进程的方式，连续两次fork可以让子进程获得孙子进程，子进程在父进程不知晓的情况下被杀死，孙子进程就会被init接管并回收，此时init也能知道子进程已经挂掉从而回收子进程。

### 线程
&#160;&#160;&#160;&#160;&#160;&#160;线程是编程时进场会用到的一个概念，它是比进程更小的系统调度单位，是系统最小的执行调度单位，有事也被称为轻量级线程。它和进程一样，被创建时，也有自己的资源范围，但是在同一个进程中不同的线程之间很多资源是共享的。例如所属的进程的堆资源等等。他们之间也有属于自己的堆和栈，彼此之间不共享。由于创建线程的时候系统不用像进程一样分配大量资源，创建时间也更加快。线程的调度方式为系统调用，将CPU使用权交给第一个线程，使用一段时间后强制停止，并保存运行的状态到内存和寄存器中。等待下一次使用CPU时恢复，CPU的使用权同时也会交到下一个线程手中，程序员无法在程序中决定线程的使用权限。
<div align=center>
<img src= "https://github.com/x-d-y/blog/blob/master/source/_posts/进程、线程与协程/thread.jpg?raw=ture" width = 400>

</div>

### 进程和线程的区别与联系
&#160;&#160;&#160;&#160;&#160;&#160;
- 进程是系统分配资源的最小单位，线程是CPU最小的调度单位
- 一个进程至少有一个线程，如果一个线程崩溃，进程也会崩溃，进程崩溃不会引起其他进程崩溃，因为其他进程之间资源是独立的相互不影响，进程比线程更加健壮
- 线程的划分小于进程，线程的增加会增加程序的并发性
- 资源分配给进程，进程下的线程共享进程资源
- 进程在创建和销毁的时候消耗资源以及归还资源，耗时，耗资源
- 线程轻量级，但是线程之间的执行顺序难以把控，调试更加复杂，需要加各种锁

### 协程
&#160;&#160;&#160;&#160;&#160;&#160;协程的单位更加小，协程可以理解为由程序员控制的更加轻量级的线程(图)，它不被操作系统所管理。没有频繁的切换和调度。所以时间开销更小，并且更好把控。属于用户态执行，极大地提升了程序的运行效率，不过不是所有的语言都支持协程，目前支持协程的语言有JavaScript、python、kotlin和go。有些语言如java通过相关的库调用也能模拟协程。下一篇文章将着重讲解go语言的协程(goroutine)机制。
<div align=center>
<img src= "https://github.com/x-d-y/blog/blob/master/source/_posts/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%8D%8F%E7%A8%8B/coroutine.jpeg?raw=true" width = 500>
</div>





